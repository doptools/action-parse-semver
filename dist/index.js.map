{"version":3,"file":"index.js","sources":["../webpack://@doptools/action-parse-semver/./dist/index.js","../webpack://@doptools/action-parse-semver/./node_modules/@actions/core/lib/command.js","../webpack://@doptools/action-parse-semver/./node_modules/@actions/core/lib/core.js","../webpack://@doptools/action-parse-semver/./node_modules/@actions/core/lib/file-command.js","../webpack://@doptools/action-parse-semver/./node_modules/@actions/core/lib/utils.js","../webpack://@doptools/action-parse-semver/../tslib-semver/dist/tslib-semver.umd.js","../webpack://@doptools/action-parse-semver/external \"fs\"","../webpack://@doptools/action-parse-semver/external \"os\"","../webpack://@doptools/action-parse-semver/external \"path\"","../webpack://@doptools/action-parse-semver/webpack/bootstrap","../webpack://@doptools/action-parse-semver/webpack/runtime/compat","../webpack://@doptools/action-parse-semver/webpack/startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_semver_1 = require(\"@doptools/tslib-semver\");\nconst core_1 = require(\"@actions/core\");\nconst versionRaw = core_1.getInput('version', { required: true });\nconst versionRegex = core_1.getInput('versionRegex', { required: true });\nconst errOnInvalidIn = core_1.getInput('errorOnInvalid', { required: false });\nlet errOnInvalid = true;\nswitch (errOnInvalidIn.trim().toLowerCase()) {\n    case '':\n    case 'false':\n    case '0':\n        errOnInvalid = false;\n        break;\n}\nlet version = versionRaw;\ntry {\n    if (versionRegex) {\n        const matches = new RegExp(versionRegex, 'g').exec(versionRaw);\n        if (matches === null) {\n            throw new Error(`No match found in '${versionRaw}' for '${versionRegex}'`);\n        }\n        if (matches.length > 2) {\n            throw new Error(`Found more than one match in '${versionRaw}' for '${versionRegex}'`);\n        }\n        version = matches[1];\n    }\n}\ncatch (e) {\n    if (errOnInvalid) {\n        throw e;\n    }\n}\nconst semVer = new tslib_semver_1.Semversion(version);\nif (errOnInvalid && !semVer.isValid) {\n    throw new Error(`'${version}' is not a valid semver`);\n}\nif (semVer.isValid) {\n    core_1.setOutput('build', semVer.build);\n    core_1.setOutput('version', semVer.version);\n    core_1.setOutput('full', semVer.full);\n    core_1.setOutput('hasBuild', semVer.hasBuild);\n    core_1.setOutput('isPrerelease', semVer.isPrerelease);\n    core_1.setOutput('isValid', semVer.isValid);\n    core_1.setOutput('major', semVer.major);\n    core_1.setOutput('minor', semVer.minor);\n    core_1.setOutput('patch', semVer.patch);\n    core_1.setOutput('prerelease', semVer.prerelease);\n    core_1.setOutput('prereleaseId', semVer.prereleaseId);\n    core_1.setOutput('raw', semVer.raw);\n}\nelse {\n    core_1.setOutput('raw', version);\n    core_1.setOutput('isValid', false);\n}\n","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.  The value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n */\nfunction error(message) {\n    command_1.issue('error', message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds an warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n */\nfunction warning(message) {\n    command_1.issue('warning', message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n//# sourceMappingURL=utils.js.map","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.tslibSemver = {}));\n}(this, (function (exports) { 'use strict';\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\t// Note: this is the semver.org version of the spec that it implements\n\t// Not necessarily the package version of this code.\n\tconst SEMVER_SPEC_VERSION = '2.0.0';\n\n\tconst MAX_LENGTH = 256;\n\tconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n\t  /* istanbul ignore next */ 9007199254740991;\n\n\t// Max safe segment length for coercion.\n\tconst MAX_SAFE_COMPONENT_LENGTH = 16;\n\n\tvar constants = {\n\t  SEMVER_SPEC_VERSION,\n\t  MAX_LENGTH,\n\t  MAX_SAFE_INTEGER,\n\t  MAX_SAFE_COMPONENT_LENGTH\n\t};\n\n\tconst debug = (\n\t  typeof process === 'object' &&\n\t  process.env &&\n\t  process.env.NODE_DEBUG &&\n\t  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n\t) ? (...args) => console.error('SEMVER', ...args)\n\t  : () => {};\n\n\tvar debug_1 = debug;\n\n\tvar re_1 = createCommonjsModule(function (module, exports) {\n\tconst { MAX_SAFE_COMPONENT_LENGTH } = constants;\n\n\texports = module.exports = {};\n\n\t// The actual regexps go on exports.re\n\tconst re = exports.re = [];\n\tconst src = exports.src = [];\n\tconst t = exports.t = {};\n\tlet R = 0;\n\n\tconst createToken = (name, value, isGlobal) => {\n\t  const index = R++;\n\t  debug_1(index, value);\n\t  t[name] = index;\n\t  src[index] = value;\n\t  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);\n\t};\n\n\t// The following Regular Expressions can be used for tokenizing,\n\t// validating, and parsing SemVer version strings.\n\n\t// ## Numeric Identifier\n\t// A single `0`, or a non-zero digit followed by zero or more digits.\n\n\tcreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*');\n\tcreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');\n\n\t// ## Non-numeric Identifier\n\t// Zero or more digits, followed by a letter or hyphen, and then zero or\n\t// more letters, digits, or hyphens.\n\n\tcreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*');\n\n\t// ## Main Version\n\t// Three dot-separated numeric identifiers.\n\n\tcreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n\t                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n\t                   `(${src[t.NUMERICIDENTIFIER]})`);\n\n\tcreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n\t                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n\t                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n\n\t// ## Pre-release Version Identifier\n\t// A numeric identifier, or a non-numeric identifier.\n\n\tcreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`);\n\n\tcreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`);\n\n\t// ## Pre-release Version\n\t// Hyphen, followed by one or more dot-separated pre-release version\n\t// identifiers.\n\n\tcreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n\n\tcreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n\n\t// ## Build Metadata Identifier\n\t// Any combination of digits, letters, or hyphens.\n\n\tcreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');\n\n\t// ## Build Metadata\n\t// Plus sign, followed by one or more period-separated build metadata\n\t// identifiers.\n\n\tcreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n\n\t// ## Full Version String\n\t// A main version, followed optionally by a pre-release version and\n\t// build metadata.\n\n\t// Note that the only major, minor, patch, and pre-release sections of\n\t// the version string are capturing groups.  The build metadata is not a\n\t// capturing group, because it should not ever be used in version\n\t// comparison.\n\n\tcreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`);\n\n\tcreateToken('FULL', `^${src[t.FULLPLAIN]}$`);\n\n\t// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n\t// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n\t// common in the npm registry.\n\tcreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`);\n\n\tcreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);\n\n\tcreateToken('GTLT', '((?:<|>)?=?)');\n\n\t// Something like \"2.*\" or \"1.2.x\".\n\t// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n\t// Only the first item is strictly required.\n\tcreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n\tcreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n\n\tcreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n\t                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n\t                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n\t                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n\t                   `)?)?`);\n\n\tcreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n\t                        `)?)?`);\n\n\tcreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n\tcreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n\n\t// Coercion.\n\t// Extract anything that could conceivably be a part of a valid semver\n\tcreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n\t              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n\t              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n\t              `(?:$|[^\\\\d])`);\n\tcreateToken('COERCERTL', src[t.COERCE], true);\n\n\t// Tilde ranges.\n\t// Meaning is \"reasonably at or greater than\"\n\tcreateToken('LONETILDE', '(?:~>?)');\n\n\tcreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n\texports.tildeTrimReplace = '$1~';\n\n\tcreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n\tcreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n\n\t// Caret ranges.\n\t// Meaning is \"at least and backwards compatible with\"\n\tcreateToken('LONECARET', '(?:\\\\^)');\n\n\tcreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n\texports.caretTrimReplace = '$1^';\n\n\tcreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n\tcreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n\n\t// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\n\tcreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n\tcreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n\n\t// An expression to strip any whitespace between the gtlt and the thing\n\t// it modifies, so that `> 1.2.3` ==> `>1.2.3`\n\tcreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n\texports.comparatorTrimReplace = '$1$2$3';\n\n\t// Something like `1.2.3 - 1.2.4`\n\t// Note that these all use the loose form, because they'll be\n\t// checked against either the strict or loose comparator form\n\t// later.\n\tcreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n\t                   `\\\\s+-\\\\s+` +\n\t                   `(${src[t.XRANGEPLAIN]})` +\n\t                   `\\\\s*$`);\n\n\tcreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n\t                        `\\\\s+-\\\\s+` +\n\t                        `(${src[t.XRANGEPLAINLOOSE]})` +\n\t                        `\\\\s*$`);\n\n\t// Star ranges basically just allow anything at all.\n\tcreateToken('STAR', '(<|>)?=?\\\\s*\\\\*');\n\t// >=0.0.0 is like a star\n\tcreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$');\n\tcreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$');\n\t});\n\tre_1.re;\n\tre_1.src;\n\tre_1.t;\n\tre_1.tildeTrimReplace;\n\tre_1.caretTrimReplace;\n\tre_1.comparatorTrimReplace;\n\n\t// parse out just the options we care about so we always get a consistent\n\t// obj with keys in a consistent order.\n\tconst opts = ['includePrerelease', 'loose', 'rtl'];\n\tconst parseOptions = options =>\n\t  !options ? {}\n\t  : typeof options !== 'object' ? { loose: true }\n\t  : opts.filter(k => options[k]).reduce((options, k) => {\n\t    options[k] = true;\n\t    return options\n\t  }, {});\n\tvar parseOptions_1 = parseOptions;\n\n\tconst numeric = /^[0-9]+$/;\n\tconst compareIdentifiers = (a, b) => {\n\t  const anum = numeric.test(a);\n\t  const bnum = numeric.test(b);\n\n\t  if (anum && bnum) {\n\t    a = +a;\n\t    b = +b;\n\t  }\n\n\t  return a === b ? 0\n\t    : (anum && !bnum) ? -1\n\t    : (bnum && !anum) ? 1\n\t    : a < b ? -1\n\t    : 1\n\t};\n\n\tconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);\n\n\tvar identifiers = {\n\t  compareIdentifiers,\n\t  rcompareIdentifiers\n\t};\n\n\tconst { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1 } = constants;\n\tconst { re, t } = re_1;\n\n\n\tconst { compareIdentifiers: compareIdentifiers$1 } = identifiers;\n\tclass SemVer {\n\t  constructor (version, options) {\n\t    options = parseOptions_1(options);\n\n\t    if (version instanceof SemVer) {\n\t      if (version.loose === !!options.loose &&\n\t          version.includePrerelease === !!options.includePrerelease) {\n\t        return version\n\t      } else {\n\t        version = version.version;\n\t      }\n\t    } else if (typeof version !== 'string') {\n\t      throw new TypeError(`Invalid Version: ${version}`)\n\t    }\n\n\t    if (version.length > MAX_LENGTH$1) {\n\t      throw new TypeError(\n\t        `version is longer than ${MAX_LENGTH$1} characters`\n\t      )\n\t    }\n\n\t    debug_1('SemVer', version, options);\n\t    this.options = options;\n\t    this.loose = !!options.loose;\n\t    // this isn't actually relevant for versions, but keep it so that we\n\t    // don't run into trouble passing this.options around.\n\t    this.includePrerelease = !!options.includePrerelease;\n\n\t    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n\n\t    if (!m) {\n\t      throw new TypeError(`Invalid Version: ${version}`)\n\t    }\n\n\t    this.raw = version;\n\n\t    // these are actually numbers\n\t    this.major = +m[1];\n\t    this.minor = +m[2];\n\t    this.patch = +m[3];\n\n\t    if (this.major > MAX_SAFE_INTEGER$1 || this.major < 0) {\n\t      throw new TypeError('Invalid major version')\n\t    }\n\n\t    if (this.minor > MAX_SAFE_INTEGER$1 || this.minor < 0) {\n\t      throw new TypeError('Invalid minor version')\n\t    }\n\n\t    if (this.patch > MAX_SAFE_INTEGER$1 || this.patch < 0) {\n\t      throw new TypeError('Invalid patch version')\n\t    }\n\n\t    // numberify any prerelease numeric ids\n\t    if (!m[4]) {\n\t      this.prerelease = [];\n\t    } else {\n\t      this.prerelease = m[4].split('.').map((id) => {\n\t        if (/^[0-9]+$/.test(id)) {\n\t          const num = +id;\n\t          if (num >= 0 && num < MAX_SAFE_INTEGER$1) {\n\t            return num\n\t          }\n\t        }\n\t        return id\n\t      });\n\t    }\n\n\t    this.build = m[5] ? m[5].split('.') : [];\n\t    this.format();\n\t  }\n\n\t  format () {\n\t    this.version = `${this.major}.${this.minor}.${this.patch}`;\n\t    if (this.prerelease.length) {\n\t      this.version += `-${this.prerelease.join('.')}`;\n\t    }\n\t    return this.version\n\t  }\n\n\t  toString () {\n\t    return this.version\n\t  }\n\n\t  compare (other) {\n\t    debug_1('SemVer.compare', this.version, this.options, other);\n\t    if (!(other instanceof SemVer)) {\n\t      if (typeof other === 'string' && other === this.version) {\n\t        return 0\n\t      }\n\t      other = new SemVer(other, this.options);\n\t    }\n\n\t    if (other.version === this.version) {\n\t      return 0\n\t    }\n\n\t    return this.compareMain(other) || this.comparePre(other)\n\t  }\n\n\t  compareMain (other) {\n\t    if (!(other instanceof SemVer)) {\n\t      other = new SemVer(other, this.options);\n\t    }\n\n\t    return (\n\t      compareIdentifiers$1(this.major, other.major) ||\n\t      compareIdentifiers$1(this.minor, other.minor) ||\n\t      compareIdentifiers$1(this.patch, other.patch)\n\t    )\n\t  }\n\n\t  comparePre (other) {\n\t    if (!(other instanceof SemVer)) {\n\t      other = new SemVer(other, this.options);\n\t    }\n\n\t    // NOT having a prerelease is > having one\n\t    if (this.prerelease.length && !other.prerelease.length) {\n\t      return -1\n\t    } else if (!this.prerelease.length && other.prerelease.length) {\n\t      return 1\n\t    } else if (!this.prerelease.length && !other.prerelease.length) {\n\t      return 0\n\t    }\n\n\t    let i = 0;\n\t    do {\n\t      const a = this.prerelease[i];\n\t      const b = other.prerelease[i];\n\t      debug_1('prerelease compare', i, a, b);\n\t      if (a === undefined && b === undefined) {\n\t        return 0\n\t      } else if (b === undefined) {\n\t        return 1\n\t      } else if (a === undefined) {\n\t        return -1\n\t      } else if (a === b) {\n\t        continue\n\t      } else {\n\t        return compareIdentifiers$1(a, b)\n\t      }\n\t    } while (++i)\n\t  }\n\n\t  compareBuild (other) {\n\t    if (!(other instanceof SemVer)) {\n\t      other = new SemVer(other, this.options);\n\t    }\n\n\t    let i = 0;\n\t    do {\n\t      const a = this.build[i];\n\t      const b = other.build[i];\n\t      debug_1('prerelease compare', i, a, b);\n\t      if (a === undefined && b === undefined) {\n\t        return 0\n\t      } else if (b === undefined) {\n\t        return 1\n\t      } else if (a === undefined) {\n\t        return -1\n\t      } else if (a === b) {\n\t        continue\n\t      } else {\n\t        return compareIdentifiers$1(a, b)\n\t      }\n\t    } while (++i)\n\t  }\n\n\t  // preminor will bump the version up to the next minor release, and immediately\n\t  // down to pre-release. premajor and prepatch work the same way.\n\t  inc (release, identifier) {\n\t    switch (release) {\n\t      case 'premajor':\n\t        this.prerelease.length = 0;\n\t        this.patch = 0;\n\t        this.minor = 0;\n\t        this.major++;\n\t        this.inc('pre', identifier);\n\t        break\n\t      case 'preminor':\n\t        this.prerelease.length = 0;\n\t        this.patch = 0;\n\t        this.minor++;\n\t        this.inc('pre', identifier);\n\t        break\n\t      case 'prepatch':\n\t        // If this is already a prerelease, it will bump to the next version\n\t        // drop any prereleases that might already exist, since they are not\n\t        // relevant at this point.\n\t        this.prerelease.length = 0;\n\t        this.inc('patch', identifier);\n\t        this.inc('pre', identifier);\n\t        break\n\t      // If the input is a non-prerelease version, this acts the same as\n\t      // prepatch.\n\t      case 'prerelease':\n\t        if (this.prerelease.length === 0) {\n\t          this.inc('patch', identifier);\n\t        }\n\t        this.inc('pre', identifier);\n\t        break\n\n\t      case 'major':\n\t        // If this is a pre-major version, bump up to the same major version.\n\t        // Otherwise increment major.\n\t        // 1.0.0-5 bumps to 1.0.0\n\t        // 1.1.0 bumps to 2.0.0\n\t        if (\n\t          this.minor !== 0 ||\n\t          this.patch !== 0 ||\n\t          this.prerelease.length === 0\n\t        ) {\n\t          this.major++;\n\t        }\n\t        this.minor = 0;\n\t        this.patch = 0;\n\t        this.prerelease = [];\n\t        break\n\t      case 'minor':\n\t        // If this is a pre-minor version, bump up to the same minor version.\n\t        // Otherwise increment minor.\n\t        // 1.2.0-5 bumps to 1.2.0\n\t        // 1.2.1 bumps to 1.3.0\n\t        if (this.patch !== 0 || this.prerelease.length === 0) {\n\t          this.minor++;\n\t        }\n\t        this.patch = 0;\n\t        this.prerelease = [];\n\t        break\n\t      case 'patch':\n\t        // If this is not a pre-release version, it will increment the patch.\n\t        // If it is a pre-release it will bump up to the same patch version.\n\t        // 1.2.0-5 patches to 1.2.0\n\t        // 1.2.0 patches to 1.2.1\n\t        if (this.prerelease.length === 0) {\n\t          this.patch++;\n\t        }\n\t        this.prerelease = [];\n\t        break\n\t      // This probably shouldn't be used publicly.\n\t      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n\t      case 'pre':\n\t        if (this.prerelease.length === 0) {\n\t          this.prerelease = [0];\n\t        } else {\n\t          let i = this.prerelease.length;\n\t          while (--i >= 0) {\n\t            if (typeof this.prerelease[i] === 'number') {\n\t              this.prerelease[i]++;\n\t              i = -2;\n\t            }\n\t          }\n\t          if (i === -1) {\n\t            // didn't increment anything\n\t            this.prerelease.push(0);\n\t          }\n\t        }\n\t        if (identifier) {\n\t          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n\t          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n\t          if (this.prerelease[0] === identifier) {\n\t            if (isNaN(this.prerelease[1])) {\n\t              this.prerelease = [identifier, 0];\n\t            }\n\t          } else {\n\t            this.prerelease = [identifier, 0];\n\t          }\n\t        }\n\t        break\n\n\t      default:\n\t        throw new Error(`invalid increment argument: ${release}`)\n\t    }\n\t    this.format();\n\t    this.raw = this.version;\n\t    return this\n\t  }\n\t}\n\n\tvar semver = SemVer;\n\n\tconst {MAX_LENGTH: MAX_LENGTH$2} = constants;\n\tconst { re: re$1, t: t$1 } = re_1;\n\n\n\n\tconst parse = (version, options) => {\n\t  options = parseOptions_1(options);\n\n\t  if (version instanceof semver) {\n\t    return version\n\t  }\n\n\t  if (typeof version !== 'string') {\n\t    return null\n\t  }\n\n\t  if (version.length > MAX_LENGTH$2) {\n\t    return null\n\t  }\n\n\t  const r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL];\n\t  if (!r.test(version)) {\n\t    return null\n\t  }\n\n\t  try {\n\t    return new semver(version, options)\n\t  } catch (er) {\n\t    return null\n\t  }\n\t};\n\n\tvar parse_1 = parse;\n\n\tconst valid = (version, options) => {\n\t  const v = parse_1(version, options);\n\t  return v ? v.version : null\n\t};\n\tvar valid_1 = valid;\n\n\tconst clean = (version, options) => {\n\t  const s = parse_1(version.trim().replace(/^[=v]+/, ''), options);\n\t  return s ? s.version : null\n\t};\n\tvar clean_1 = clean;\n\n\tconst inc = (version, release, options, identifier) => {\n\t  if (typeof (options) === 'string') {\n\t    identifier = options;\n\t    options = undefined;\n\t  }\n\n\t  try {\n\t    return new semver(version, options).inc(release, identifier).version\n\t  } catch (er) {\n\t    return null\n\t  }\n\t};\n\tvar inc_1 = inc;\n\n\tconst compare = (a, b, loose) =>\n\t  new semver(a, loose).compare(new semver(b, loose));\n\n\tvar compare_1 = compare;\n\n\tconst eq = (a, b, loose) => compare_1(a, b, loose) === 0;\n\tvar eq_1 = eq;\n\n\tconst diff = (version1, version2) => {\n\t  if (eq_1(version1, version2)) {\n\t    return null\n\t  } else {\n\t    const v1 = parse_1(version1);\n\t    const v2 = parse_1(version2);\n\t    const hasPre = v1.prerelease.length || v2.prerelease.length;\n\t    const prefix = hasPre ? 'pre' : '';\n\t    const defaultResult = hasPre ? 'prerelease' : '';\n\t    for (const key in v1) {\n\t      if (key === 'major' || key === 'minor' || key === 'patch') {\n\t        if (v1[key] !== v2[key]) {\n\t          return prefix + key\n\t        }\n\t      }\n\t    }\n\t    return defaultResult // may be undefined\n\t  }\n\t};\n\tvar diff_1 = diff;\n\n\tconst major = (a, loose) => new semver(a, loose).major;\n\tvar major_1 = major;\n\n\tconst minor = (a, loose) => new semver(a, loose).minor;\n\tvar minor_1 = minor;\n\n\tconst patch = (a, loose) => new semver(a, loose).patch;\n\tvar patch_1 = patch;\n\n\tconst prerelease = (version, options) => {\n\t  const parsed = parse_1(version, options);\n\t  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n\t};\n\tvar prerelease_1 = prerelease;\n\n\tconst rcompare = (a, b, loose) => compare_1(b, a, loose);\n\tvar rcompare_1 = rcompare;\n\n\tconst compareLoose = (a, b) => compare_1(a, b, true);\n\tvar compareLoose_1 = compareLoose;\n\n\tconst compareBuild = (a, b, loose) => {\n\t  const versionA = new semver(a, loose);\n\t  const versionB = new semver(b, loose);\n\t  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n\t};\n\tvar compareBuild_1 = compareBuild;\n\n\tconst sort = (list, loose) => list.sort((a, b) => compareBuild_1(a, b, loose));\n\tvar sort_1 = sort;\n\n\tconst rsort = (list, loose) => list.sort((a, b) => compareBuild_1(b, a, loose));\n\tvar rsort_1 = rsort;\n\n\tconst gt = (a, b, loose) => compare_1(a, b, loose) > 0;\n\tvar gt_1 = gt;\n\n\tconst lt = (a, b, loose) => compare_1(a, b, loose) < 0;\n\tvar lt_1 = lt;\n\n\tconst neq = (a, b, loose) => compare_1(a, b, loose) !== 0;\n\tvar neq_1 = neq;\n\n\tconst gte = (a, b, loose) => compare_1(a, b, loose) >= 0;\n\tvar gte_1 = gte;\n\n\tconst lte = (a, b, loose) => compare_1(a, b, loose) <= 0;\n\tvar lte_1 = lte;\n\n\tconst cmp = (a, op, b, loose) => {\n\t  switch (op) {\n\t    case '===':\n\t      if (typeof a === 'object')\n\t        a = a.version;\n\t      if (typeof b === 'object')\n\t        b = b.version;\n\t      return a === b\n\n\t    case '!==':\n\t      if (typeof a === 'object')\n\t        a = a.version;\n\t      if (typeof b === 'object')\n\t        b = b.version;\n\t      return a !== b\n\n\t    case '':\n\t    case '=':\n\t    case '==':\n\t      return eq_1(a, b, loose)\n\n\t    case '!=':\n\t      return neq_1(a, b, loose)\n\n\t    case '>':\n\t      return gt_1(a, b, loose)\n\n\t    case '>=':\n\t      return gte_1(a, b, loose)\n\n\t    case '<':\n\t      return lt_1(a, b, loose)\n\n\t    case '<=':\n\t      return lte_1(a, b, loose)\n\n\t    default:\n\t      throw new TypeError(`Invalid operator: ${op}`)\n\t  }\n\t};\n\tvar cmp_1 = cmp;\n\n\tconst {re: re$2, t: t$2} = re_1;\n\n\tconst coerce = (version, options) => {\n\t  if (version instanceof semver) {\n\t    return version\n\t  }\n\n\t  if (typeof version === 'number') {\n\t    version = String(version);\n\t  }\n\n\t  if (typeof version !== 'string') {\n\t    return null\n\t  }\n\n\t  options = options || {};\n\n\t  let match = null;\n\t  if (!options.rtl) {\n\t    match = version.match(re$2[t$2.COERCE]);\n\t  } else {\n\t    // Find the right-most coercible string that does not share\n\t    // a terminus with a more left-ward coercible string.\n\t    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n\t    //\n\t    // Walk through the string checking with a /g regexp\n\t    // Manually set the index so as to pick up overlapping matches.\n\t    // Stop when we get a match that ends at the string end, since no\n\t    // coercible string can be more right-ward without the same terminus.\n\t    let next;\n\t    while ((next = re$2[t$2.COERCERTL].exec(version)) &&\n\t        (!match || match.index + match[0].length !== version.length)\n\t    ) {\n\t      if (!match ||\n\t            next.index + next[0].length !== match.index + match[0].length) {\n\t        match = next;\n\t      }\n\t      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n\t    }\n\t    // leave it in a clean state\n\t    re$2[t$2.COERCERTL].lastIndex = -1;\n\t  }\n\n\t  if (match === null)\n\t    return null\n\n\t  return parse_1(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n\t};\n\tvar coerce_1 = coerce;\n\n\tvar iterator = function (Yallist) {\n\t  Yallist.prototype[Symbol.iterator] = function* () {\n\t    for (let walker = this.head; walker; walker = walker.next) {\n\t      yield walker.value;\n\t    }\n\t  };\n\t};\n\n\tvar yallist = Yallist;\n\n\tYallist.Node = Node;\n\tYallist.create = Yallist;\n\n\tfunction Yallist (list) {\n\t  var self = this;\n\t  if (!(self instanceof Yallist)) {\n\t    self = new Yallist();\n\t  }\n\n\t  self.tail = null;\n\t  self.head = null;\n\t  self.length = 0;\n\n\t  if (list && typeof list.forEach === 'function') {\n\t    list.forEach(function (item) {\n\t      self.push(item);\n\t    });\n\t  } else if (arguments.length > 0) {\n\t    for (var i = 0, l = arguments.length; i < l; i++) {\n\t      self.push(arguments[i]);\n\t    }\n\t  }\n\n\t  return self\n\t}\n\n\tYallist.prototype.removeNode = function (node) {\n\t  if (node.list !== this) {\n\t    throw new Error('removing node which does not belong to this list')\n\t  }\n\n\t  var next = node.next;\n\t  var prev = node.prev;\n\n\t  if (next) {\n\t    next.prev = prev;\n\t  }\n\n\t  if (prev) {\n\t    prev.next = next;\n\t  }\n\n\t  if (node === this.head) {\n\t    this.head = next;\n\t  }\n\t  if (node === this.tail) {\n\t    this.tail = prev;\n\t  }\n\n\t  node.list.length--;\n\t  node.next = null;\n\t  node.prev = null;\n\t  node.list = null;\n\n\t  return next\n\t};\n\n\tYallist.prototype.unshiftNode = function (node) {\n\t  if (node === this.head) {\n\t    return\n\t  }\n\n\t  if (node.list) {\n\t    node.list.removeNode(node);\n\t  }\n\n\t  var head = this.head;\n\t  node.list = this;\n\t  node.next = head;\n\t  if (head) {\n\t    head.prev = node;\n\t  }\n\n\t  this.head = node;\n\t  if (!this.tail) {\n\t    this.tail = node;\n\t  }\n\t  this.length++;\n\t};\n\n\tYallist.prototype.pushNode = function (node) {\n\t  if (node === this.tail) {\n\t    return\n\t  }\n\n\t  if (node.list) {\n\t    node.list.removeNode(node);\n\t  }\n\n\t  var tail = this.tail;\n\t  node.list = this;\n\t  node.prev = tail;\n\t  if (tail) {\n\t    tail.next = node;\n\t  }\n\n\t  this.tail = node;\n\t  if (!this.head) {\n\t    this.head = node;\n\t  }\n\t  this.length++;\n\t};\n\n\tYallist.prototype.push = function () {\n\t  for (var i = 0, l = arguments.length; i < l; i++) {\n\t    push(this, arguments[i]);\n\t  }\n\t  return this.length\n\t};\n\n\tYallist.prototype.unshift = function () {\n\t  for (var i = 0, l = arguments.length; i < l; i++) {\n\t    unshift(this, arguments[i]);\n\t  }\n\t  return this.length\n\t};\n\n\tYallist.prototype.pop = function () {\n\t  if (!this.tail) {\n\t    return undefined\n\t  }\n\n\t  var res = this.tail.value;\n\t  this.tail = this.tail.prev;\n\t  if (this.tail) {\n\t    this.tail.next = null;\n\t  } else {\n\t    this.head = null;\n\t  }\n\t  this.length--;\n\t  return res\n\t};\n\n\tYallist.prototype.shift = function () {\n\t  if (!this.head) {\n\t    return undefined\n\t  }\n\n\t  var res = this.head.value;\n\t  this.head = this.head.next;\n\t  if (this.head) {\n\t    this.head.prev = null;\n\t  } else {\n\t    this.tail = null;\n\t  }\n\t  this.length--;\n\t  return res\n\t};\n\n\tYallist.prototype.forEach = function (fn, thisp) {\n\t  thisp = thisp || this;\n\t  for (var walker = this.head, i = 0; walker !== null; i++) {\n\t    fn.call(thisp, walker.value, i, this);\n\t    walker = walker.next;\n\t  }\n\t};\n\n\tYallist.prototype.forEachReverse = function (fn, thisp) {\n\t  thisp = thisp || this;\n\t  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n\t    fn.call(thisp, walker.value, i, this);\n\t    walker = walker.prev;\n\t  }\n\t};\n\n\tYallist.prototype.get = function (n) {\n\t  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n\t    // abort out of the list early if we hit a cycle\n\t    walker = walker.next;\n\t  }\n\t  if (i === n && walker !== null) {\n\t    return walker.value\n\t  }\n\t};\n\n\tYallist.prototype.getReverse = function (n) {\n\t  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n\t    // abort out of the list early if we hit a cycle\n\t    walker = walker.prev;\n\t  }\n\t  if (i === n && walker !== null) {\n\t    return walker.value\n\t  }\n\t};\n\n\tYallist.prototype.map = function (fn, thisp) {\n\t  thisp = thisp || this;\n\t  var res = new Yallist();\n\t  for (var walker = this.head; walker !== null;) {\n\t    res.push(fn.call(thisp, walker.value, this));\n\t    walker = walker.next;\n\t  }\n\t  return res\n\t};\n\n\tYallist.prototype.mapReverse = function (fn, thisp) {\n\t  thisp = thisp || this;\n\t  var res = new Yallist();\n\t  for (var walker = this.tail; walker !== null;) {\n\t    res.push(fn.call(thisp, walker.value, this));\n\t    walker = walker.prev;\n\t  }\n\t  return res\n\t};\n\n\tYallist.prototype.reduce = function (fn, initial) {\n\t  var acc;\n\t  var walker = this.head;\n\t  if (arguments.length > 1) {\n\t    acc = initial;\n\t  } else if (this.head) {\n\t    walker = this.head.next;\n\t    acc = this.head.value;\n\t  } else {\n\t    throw new TypeError('Reduce of empty list with no initial value')\n\t  }\n\n\t  for (var i = 0; walker !== null; i++) {\n\t    acc = fn(acc, walker.value, i);\n\t    walker = walker.next;\n\t  }\n\n\t  return acc\n\t};\n\n\tYallist.prototype.reduceReverse = function (fn, initial) {\n\t  var acc;\n\t  var walker = this.tail;\n\t  if (arguments.length > 1) {\n\t    acc = initial;\n\t  } else if (this.tail) {\n\t    walker = this.tail.prev;\n\t    acc = this.tail.value;\n\t  } else {\n\t    throw new TypeError('Reduce of empty list with no initial value')\n\t  }\n\n\t  for (var i = this.length - 1; walker !== null; i--) {\n\t    acc = fn(acc, walker.value, i);\n\t    walker = walker.prev;\n\t  }\n\n\t  return acc\n\t};\n\n\tYallist.prototype.toArray = function () {\n\t  var arr = new Array(this.length);\n\t  for (var i = 0, walker = this.head; walker !== null; i++) {\n\t    arr[i] = walker.value;\n\t    walker = walker.next;\n\t  }\n\t  return arr\n\t};\n\n\tYallist.prototype.toArrayReverse = function () {\n\t  var arr = new Array(this.length);\n\t  for (var i = 0, walker = this.tail; walker !== null; i++) {\n\t    arr[i] = walker.value;\n\t    walker = walker.prev;\n\t  }\n\t  return arr\n\t};\n\n\tYallist.prototype.slice = function (from, to) {\n\t  to = to || this.length;\n\t  if (to < 0) {\n\t    to += this.length;\n\t  }\n\t  from = from || 0;\n\t  if (from < 0) {\n\t    from += this.length;\n\t  }\n\t  var ret = new Yallist();\n\t  if (to < from || to < 0) {\n\t    return ret\n\t  }\n\t  if (from < 0) {\n\t    from = 0;\n\t  }\n\t  if (to > this.length) {\n\t    to = this.length;\n\t  }\n\t  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n\t    walker = walker.next;\n\t  }\n\t  for (; walker !== null && i < to; i++, walker = walker.next) {\n\t    ret.push(walker.value);\n\t  }\n\t  return ret\n\t};\n\n\tYallist.prototype.sliceReverse = function (from, to) {\n\t  to = to || this.length;\n\t  if (to < 0) {\n\t    to += this.length;\n\t  }\n\t  from = from || 0;\n\t  if (from < 0) {\n\t    from += this.length;\n\t  }\n\t  var ret = new Yallist();\n\t  if (to < from || to < 0) {\n\t    return ret\n\t  }\n\t  if (from < 0) {\n\t    from = 0;\n\t  }\n\t  if (to > this.length) {\n\t    to = this.length;\n\t  }\n\t  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n\t    walker = walker.prev;\n\t  }\n\t  for (; walker !== null && i > from; i--, walker = walker.prev) {\n\t    ret.push(walker.value);\n\t  }\n\t  return ret\n\t};\n\n\tYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n\t  if (start > this.length) {\n\t    start = this.length - 1;\n\t  }\n\t  if (start < 0) {\n\t    start = this.length + start;\n\t  }\n\n\t  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n\t    walker = walker.next;\n\t  }\n\n\t  var ret = [];\n\t  for (var i = 0; walker && i < deleteCount; i++) {\n\t    ret.push(walker.value);\n\t    walker = this.removeNode(walker);\n\t  }\n\t  if (walker === null) {\n\t    walker = this.tail;\n\t  }\n\n\t  if (walker !== this.head && walker !== this.tail) {\n\t    walker = walker.prev;\n\t  }\n\n\t  for (var i = 0; i < nodes.length; i++) {\n\t    walker = insert(this, walker, nodes[i]);\n\t  }\n\t  return ret;\n\t};\n\n\tYallist.prototype.reverse = function () {\n\t  var head = this.head;\n\t  var tail = this.tail;\n\t  for (var walker = head; walker !== null; walker = walker.prev) {\n\t    var p = walker.prev;\n\t    walker.prev = walker.next;\n\t    walker.next = p;\n\t  }\n\t  this.head = tail;\n\t  this.tail = head;\n\t  return this\n\t};\n\n\tfunction insert (self, node, value) {\n\t  var inserted = node === self.head ?\n\t    new Node(value, null, node, self) :\n\t    new Node(value, node, node.next, self);\n\n\t  if (inserted.next === null) {\n\t    self.tail = inserted;\n\t  }\n\t  if (inserted.prev === null) {\n\t    self.head = inserted;\n\t  }\n\n\t  self.length++;\n\n\t  return inserted\n\t}\n\n\tfunction push (self, item) {\n\t  self.tail = new Node(item, self.tail, null, self);\n\t  if (!self.head) {\n\t    self.head = self.tail;\n\t  }\n\t  self.length++;\n\t}\n\n\tfunction unshift (self, item) {\n\t  self.head = new Node(item, null, self.head, self);\n\t  if (!self.tail) {\n\t    self.tail = self.head;\n\t  }\n\t  self.length++;\n\t}\n\n\tfunction Node (value, prev, next, list) {\n\t  if (!(this instanceof Node)) {\n\t    return new Node(value, prev, next, list)\n\t  }\n\n\t  this.list = list;\n\t  this.value = value;\n\n\t  if (prev) {\n\t    prev.next = this;\n\t    this.prev = prev;\n\t  } else {\n\t    this.prev = null;\n\t  }\n\n\t  if (next) {\n\t    next.prev = this;\n\t    this.next = next;\n\t  } else {\n\t    this.next = null;\n\t  }\n\t}\n\n\ttry {\n\t  // add if support for Symbol.iterator is present\n\t  iterator(Yallist);\n\t} catch (er) {}\n\n\t// A linked list to keep track of recently-used-ness\n\n\n\tconst MAX = Symbol('max');\n\tconst LENGTH = Symbol('length');\n\tconst LENGTH_CALCULATOR = Symbol('lengthCalculator');\n\tconst ALLOW_STALE = Symbol('allowStale');\n\tconst MAX_AGE = Symbol('maxAge');\n\tconst DISPOSE = Symbol('dispose');\n\tconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');\n\tconst LRU_LIST = Symbol('lruList');\n\tconst CACHE = Symbol('cache');\n\tconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');\n\n\tconst naiveLength = () => 1;\n\n\t// lruList is a yallist where the head is the youngest\n\t// item, and the tail is the oldest.  the list contains the Hit\n\t// objects as the entries.\n\t// Each Hit object has a reference to its Yallist.Node.  This\n\t// never changes.\n\t//\n\t// cache is a Map (or PseudoMap) that matches the keys to\n\t// the Yallist.Node object.\n\tclass LRUCache {\n\t  constructor (options) {\n\t    if (typeof options === 'number')\n\t      options = { max: options };\n\n\t    if (!options)\n\t      options = {};\n\n\t    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n\t      throw new TypeError('max must be a non-negative number')\n\t    // Kind of weird to have a default max of Infinity, but oh well.\n\t    this[MAX] = options.max || Infinity;\n\n\t    const lc = options.length || naiveLength;\n\t    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;\n\t    this[ALLOW_STALE] = options.stale || false;\n\t    if (options.maxAge && typeof options.maxAge !== 'number')\n\t      throw new TypeError('maxAge must be a number')\n\t    this[MAX_AGE] = options.maxAge || 0;\n\t    this[DISPOSE] = options.dispose;\n\t    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n\t    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;\n\t    this.reset();\n\t  }\n\n\t  // resize the cache when the max changes.\n\t  set max (mL) {\n\t    if (typeof mL !== 'number' || mL < 0)\n\t      throw new TypeError('max must be a non-negative number')\n\n\t    this[MAX] = mL || Infinity;\n\t    trim(this);\n\t  }\n\t  get max () {\n\t    return this[MAX]\n\t  }\n\n\t  set allowStale (allowStale) {\n\t    this[ALLOW_STALE] = !!allowStale;\n\t  }\n\t  get allowStale () {\n\t    return this[ALLOW_STALE]\n\t  }\n\n\t  set maxAge (mA) {\n\t    if (typeof mA !== 'number')\n\t      throw new TypeError('maxAge must be a non-negative number')\n\n\t    this[MAX_AGE] = mA;\n\t    trim(this);\n\t  }\n\t  get maxAge () {\n\t    return this[MAX_AGE]\n\t  }\n\n\t  // resize the cache when the lengthCalculator changes.\n\t  set lengthCalculator (lC) {\n\t    if (typeof lC !== 'function')\n\t      lC = naiveLength;\n\n\t    if (lC !== this[LENGTH_CALCULATOR]) {\n\t      this[LENGTH_CALCULATOR] = lC;\n\t      this[LENGTH] = 0;\n\t      this[LRU_LIST].forEach(hit => {\n\t        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n\t        this[LENGTH] += hit.length;\n\t      });\n\t    }\n\t    trim(this);\n\t  }\n\t  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n\t  get length () { return this[LENGTH] }\n\t  get itemCount () { return this[LRU_LIST].length }\n\n\t  rforEach (fn, thisp) {\n\t    thisp = thisp || this;\n\t    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n\t      const prev = walker.prev;\n\t      forEachStep(this, fn, walker, thisp);\n\t      walker = prev;\n\t    }\n\t  }\n\n\t  forEach (fn, thisp) {\n\t    thisp = thisp || this;\n\t    for (let walker = this[LRU_LIST].head; walker !== null;) {\n\t      const next = walker.next;\n\t      forEachStep(this, fn, walker, thisp);\n\t      walker = next;\n\t    }\n\t  }\n\n\t  keys () {\n\t    return this[LRU_LIST].toArray().map(k => k.key)\n\t  }\n\n\t  values () {\n\t    return this[LRU_LIST].toArray().map(k => k.value)\n\t  }\n\n\t  reset () {\n\t    if (this[DISPOSE] &&\n\t        this[LRU_LIST] &&\n\t        this[LRU_LIST].length) {\n\t      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));\n\t    }\n\n\t    this[CACHE] = new Map(); // hash of items by key\n\t    this[LRU_LIST] = new yallist(); // list of items in order of use recency\n\t    this[LENGTH] = 0; // length of items in the list\n\t  }\n\n\t  dump () {\n\t    return this[LRU_LIST].map(hit =>\n\t      isStale(this, hit) ? false : {\n\t        k: hit.key,\n\t        v: hit.value,\n\t        e: hit.now + (hit.maxAge || 0)\n\t      }).toArray().filter(h => h)\n\t  }\n\n\t  dumpLru () {\n\t    return this[LRU_LIST]\n\t  }\n\n\t  set (key, value, maxAge) {\n\t    maxAge = maxAge || this[MAX_AGE];\n\n\t    if (maxAge && typeof maxAge !== 'number')\n\t      throw new TypeError('maxAge must be a number')\n\n\t    const now = maxAge ? Date.now() : 0;\n\t    const len = this[LENGTH_CALCULATOR](value, key);\n\n\t    if (this[CACHE].has(key)) {\n\t      if (len > this[MAX]) {\n\t        del(this, this[CACHE].get(key));\n\t        return false\n\t      }\n\n\t      const node = this[CACHE].get(key);\n\t      const item = node.value;\n\n\t      // dispose of the old one before overwriting\n\t      // split out into 2 ifs for better coverage tracking\n\t      if (this[DISPOSE]) {\n\t        if (!this[NO_DISPOSE_ON_SET])\n\t          this[DISPOSE](key, item.value);\n\t      }\n\n\t      item.now = now;\n\t      item.maxAge = maxAge;\n\t      item.value = value;\n\t      this[LENGTH] += len - item.length;\n\t      item.length = len;\n\t      this.get(key);\n\t      trim(this);\n\t      return true\n\t    }\n\n\t    const hit = new Entry(key, value, len, now, maxAge);\n\n\t    // oversized objects fall out of cache automatically.\n\t    if (hit.length > this[MAX]) {\n\t      if (this[DISPOSE])\n\t        this[DISPOSE](key, value);\n\n\t      return false\n\t    }\n\n\t    this[LENGTH] += hit.length;\n\t    this[LRU_LIST].unshift(hit);\n\t    this[CACHE].set(key, this[LRU_LIST].head);\n\t    trim(this);\n\t    return true\n\t  }\n\n\t  has (key) {\n\t    if (!this[CACHE].has(key)) return false\n\t    const hit = this[CACHE].get(key).value;\n\t    return !isStale(this, hit)\n\t  }\n\n\t  get (key) {\n\t    return get(this, key, true)\n\t  }\n\n\t  peek (key) {\n\t    return get(this, key, false)\n\t  }\n\n\t  pop () {\n\t    const node = this[LRU_LIST].tail;\n\t    if (!node)\n\t      return null\n\n\t    del(this, node);\n\t    return node.value\n\t  }\n\n\t  del (key) {\n\t    del(this, this[CACHE].get(key));\n\t  }\n\n\t  load (arr) {\n\t    // reset the cache\n\t    this.reset();\n\n\t    const now = Date.now();\n\t    // A previous serialized cache has the most recent items first\n\t    for (let l = arr.length - 1; l >= 0; l--) {\n\t      const hit = arr[l];\n\t      const expiresAt = hit.e || 0;\n\t      if (expiresAt === 0)\n\t        // the item was created without expiration in a non aged cache\n\t        this.set(hit.k, hit.v);\n\t      else {\n\t        const maxAge = expiresAt - now;\n\t        // dont add already expired items\n\t        if (maxAge > 0) {\n\t          this.set(hit.k, hit.v, maxAge);\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  prune () {\n\t    this[CACHE].forEach((value, key) => get(this, key, false));\n\t  }\n\t}\n\n\tconst get = (self, key, doUse) => {\n\t  const node = self[CACHE].get(key);\n\t  if (node) {\n\t    const hit = node.value;\n\t    if (isStale(self, hit)) {\n\t      del(self, node);\n\t      if (!self[ALLOW_STALE])\n\t        return undefined\n\t    } else {\n\t      if (doUse) {\n\t        if (self[UPDATE_AGE_ON_GET])\n\t          node.value.now = Date.now();\n\t        self[LRU_LIST].unshiftNode(node);\n\t      }\n\t    }\n\t    return hit.value\n\t  }\n\t};\n\n\tconst isStale = (self, hit) => {\n\t  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n\t    return false\n\n\t  const diff = Date.now() - hit.now;\n\t  return hit.maxAge ? diff > hit.maxAge\n\t    : self[MAX_AGE] && (diff > self[MAX_AGE])\n\t};\n\n\tconst trim = self => {\n\t  if (self[LENGTH] > self[MAX]) {\n\t    for (let walker = self[LRU_LIST].tail;\n\t      self[LENGTH] > self[MAX] && walker !== null;) {\n\t      // We know that we're about to delete this one, and also\n\t      // what the next least recently used key will be, so just\n\t      // go ahead and set it now.\n\t      const prev = walker.prev;\n\t      del(self, walker);\n\t      walker = prev;\n\t    }\n\t  }\n\t};\n\n\tconst del = (self, node) => {\n\t  if (node) {\n\t    const hit = node.value;\n\t    if (self[DISPOSE])\n\t      self[DISPOSE](hit.key, hit.value);\n\n\t    self[LENGTH] -= hit.length;\n\t    self[CACHE].delete(hit.key);\n\t    self[LRU_LIST].removeNode(node);\n\t  }\n\t};\n\n\tclass Entry {\n\t  constructor (key, value, length, now, maxAge) {\n\t    this.key = key;\n\t    this.value = value;\n\t    this.length = length;\n\t    this.now = now;\n\t    this.maxAge = maxAge || 0;\n\t  }\n\t}\n\n\tconst forEachStep = (self, fn, node, thisp) => {\n\t  let hit = node.value;\n\t  if (isStale(self, hit)) {\n\t    del(self, node);\n\t    if (!self[ALLOW_STALE])\n\t      hit = undefined;\n\t  }\n\t  if (hit)\n\t    fn.call(thisp, hit.value, hit.key, self);\n\t};\n\n\tvar lruCache = LRUCache;\n\n\t// hoisted class for cyclic dependency\n\tclass Range {\n\t  constructor (range, options) {\n\t    options = parseOptions_1(options);\n\n\t    if (range instanceof Range) {\n\t      if (\n\t        range.loose === !!options.loose &&\n\t        range.includePrerelease === !!options.includePrerelease\n\t      ) {\n\t        return range\n\t      } else {\n\t        return new Range(range.raw, options)\n\t      }\n\t    }\n\n\t    if (range instanceof comparator) {\n\t      // just put it in the set and return\n\t      this.raw = range.value;\n\t      this.set = [[range]];\n\t      this.format();\n\t      return this\n\t    }\n\n\t    this.options = options;\n\t    this.loose = !!options.loose;\n\t    this.includePrerelease = !!options.includePrerelease;\n\n\t    // First, split based on boolean or ||\n\t    this.raw = range;\n\t    this.set = range\n\t      .split(/\\s*\\|\\|\\s*/)\n\t      // map the range to a 2d array of comparators\n\t      .map(range => this.parseRange(range.trim()))\n\t      // throw out any comparator lists that are empty\n\t      // this generally means that it was not a valid range, which is allowed\n\t      // in loose mode, but will still throw if the WHOLE range is invalid.\n\t      .filter(c => c.length);\n\n\t    if (!this.set.length) {\n\t      throw new TypeError(`Invalid SemVer Range: ${range}`)\n\t    }\n\n\t    // if we have any that are not the null set, throw out null sets.\n\t    if (this.set.length > 1) {\n\t      // keep the first one, in case they're all null sets\n\t      const first = this.set[0];\n\t      this.set = this.set.filter(c => !isNullSet(c[0]));\n\t      if (this.set.length === 0)\n\t        this.set = [first];\n\t      else if (this.set.length > 1) {\n\t        // if we have any that are *, then the range is just *\n\t        for (const c of this.set) {\n\t          if (c.length === 1 && isAny(c[0])) {\n\t            this.set = [c];\n\t            break\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    this.format();\n\t  }\n\n\t  format () {\n\t    this.range = this.set\n\t      .map((comps) => {\n\t        return comps.join(' ').trim()\n\t      })\n\t      .join('||')\n\t      .trim();\n\t    return this.range\n\t  }\n\n\t  toString () {\n\t    return this.range\n\t  }\n\n\t  parseRange (range) {\n\t    range = range.trim();\n\n\t    // memoize range parsing for performance.\n\t    // this is a very hot path, and fully deterministic.\n\t    const memoOpts = Object.keys(this.options).join(',');\n\t    const memoKey = `parseRange:${memoOpts}:${range}`;\n\t    const cached = cache.get(memoKey);\n\t    if (cached)\n\t      return cached\n\n\t    const loose = this.options.loose;\n\t    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n\t    const hr = loose ? re$3[t$3.HYPHENRANGELOOSE] : re$3[t$3.HYPHENRANGE];\n\t    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));\n\t    debug_1('hyphen replace', range);\n\t    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n\t    range = range.replace(re$3[t$3.COMPARATORTRIM], comparatorTrimReplace);\n\t    debug_1('comparator trim', range, re$3[t$3.COMPARATORTRIM]);\n\n\t    // `~ 1.2.3` => `~1.2.3`\n\t    range = range.replace(re$3[t$3.TILDETRIM], tildeTrimReplace);\n\n\t    // `^ 1.2.3` => `^1.2.3`\n\t    range = range.replace(re$3[t$3.CARETTRIM], caretTrimReplace);\n\n\t    // normalize spaces\n\t    range = range.split(/\\s+/).join(' ');\n\n\t    // At this point, the range is completely trimmed and\n\t    // ready to be split into comparators.\n\n\t    const compRe = loose ? re$3[t$3.COMPARATORLOOSE] : re$3[t$3.COMPARATOR];\n\t    const rangeList = range\n\t      .split(' ')\n\t      .map(comp => parseComparator(comp, this.options))\n\t      .join(' ')\n\t      .split(/\\s+/)\n\t      // >=0.0.0 is equivalent to *\n\t      .map(comp => replaceGTE0(comp, this.options))\n\t      // in loose mode, throw out any that are not valid comparators\n\t      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n\t      .map(comp => new comparator(comp, this.options));\n\n\t    // if any comparators are the null set, then replace with JUST null set\n\t    // if more than one comparator, remove any * comparators\n\t    // also, don't include the same comparator more than once\n\t    rangeList.length;\n\t    const rangeMap = new Map();\n\t    for (const comp of rangeList) {\n\t      if (isNullSet(comp))\n\t        return [comp]\n\t      rangeMap.set(comp.value, comp);\n\t    }\n\t    if (rangeMap.size > 1 && rangeMap.has(''))\n\t      rangeMap.delete('');\n\n\t    const result = [...rangeMap.values()];\n\t    cache.set(memoKey, result);\n\t    return result\n\t  }\n\n\t  intersects (range, options) {\n\t    if (!(range instanceof Range)) {\n\t      throw new TypeError('a Range is required')\n\t    }\n\n\t    return this.set.some((thisComparators) => {\n\t      return (\n\t        isSatisfiable(thisComparators, options) &&\n\t        range.set.some((rangeComparators) => {\n\t          return (\n\t            isSatisfiable(rangeComparators, options) &&\n\t            thisComparators.every((thisComparator) => {\n\t              return rangeComparators.every((rangeComparator) => {\n\t                return thisComparator.intersects(rangeComparator, options)\n\t              })\n\t            })\n\t          )\n\t        })\n\t      )\n\t    })\n\t  }\n\n\t  // if ANY of the sets match ALL of its comparators, then pass\n\t  test (version) {\n\t    if (!version) {\n\t      return false\n\t    }\n\n\t    if (typeof version === 'string') {\n\t      try {\n\t        version = new semver(version, this.options);\n\t      } catch (er) {\n\t        return false\n\t      }\n\t    }\n\n\t    for (let i = 0; i < this.set.length; i++) {\n\t      if (testSet(this.set[i], version, this.options)) {\n\t        return true\n\t      }\n\t    }\n\t    return false\n\t  }\n\t}\n\tvar range = Range;\n\n\n\tconst cache = new lruCache({ max: 1000 });\n\n\n\n\n\n\tconst {\n\t  re: re$3,\n\t  t: t$3,\n\t  comparatorTrimReplace,\n\t  tildeTrimReplace,\n\t  caretTrimReplace\n\t} = re_1;\n\n\tconst isNullSet = c => c.value === '<0.0.0-0';\n\tconst isAny = c => c.value === '';\n\n\t// take a set of comparators and determine whether there\n\t// exists a version which can satisfy it\n\tconst isSatisfiable = (comparators, options) => {\n\t  let result = true;\n\t  const remainingComparators = comparators.slice();\n\t  let testComparator = remainingComparators.pop();\n\n\t  while (result && remainingComparators.length) {\n\t    result = remainingComparators.every((otherComparator) => {\n\t      return testComparator.intersects(otherComparator, options)\n\t    });\n\n\t    testComparator = remainingComparators.pop();\n\t  }\n\n\t  return result\n\t};\n\n\t// comprised of xranges, tildes, stars, and gtlt's at this point.\n\t// already replaced the hyphen ranges\n\t// turn into a set of JUST comparators.\n\tconst parseComparator = (comp, options) => {\n\t  debug_1('comp', comp, options);\n\t  comp = replaceCarets(comp, options);\n\t  debug_1('caret', comp);\n\t  comp = replaceTildes(comp, options);\n\t  debug_1('tildes', comp);\n\t  comp = replaceXRanges(comp, options);\n\t  debug_1('xrange', comp);\n\t  comp = replaceStars(comp, options);\n\t  debug_1('stars', comp);\n\t  return comp\n\t};\n\n\tconst isX = id => !id || id.toLowerCase() === 'x' || id === '*';\n\n\t// ~, ~> --> * (any, kinda silly)\n\t// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n\t// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n\t// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n\t// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n\t// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n\tconst replaceTildes = (comp, options) =>\n\t  comp.trim().split(/\\s+/).map((comp) => {\n\t    return replaceTilde(comp, options)\n\t  }).join(' ');\n\n\tconst replaceTilde = (comp, options) => {\n\t  const r = options.loose ? re$3[t$3.TILDELOOSE] : re$3[t$3.TILDE];\n\t  return comp.replace(r, (_, M, m, p, pr) => {\n\t    debug_1('tilde', comp, _, M, m, p, pr);\n\t    let ret;\n\n\t    if (isX(M)) {\n\t      ret = '';\n\t    } else if (isX(m)) {\n\t      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;\n\t    } else if (isX(p)) {\n\t      // ~1.2 == >=1.2.0 <1.3.0-0\n\t      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;\n\t    } else if (pr) {\n\t      debug_1('replaceTilde pr', pr);\n\t      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`;\n\t    } else {\n\t      // ~1.2.3 == >=1.2.3 <1.3.0-0\n\t      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`;\n\t    }\n\n\t    debug_1('tilde return', ret);\n\t    return ret\n\t  })\n\t};\n\n\t// ^ --> * (any, kinda silly)\n\t// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n\t// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n\t// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n\t// ^1.2.3 --> >=1.2.3 <2.0.0-0\n\t// ^1.2.0 --> >=1.2.0 <2.0.0-0\n\tconst replaceCarets = (comp, options) =>\n\t  comp.trim().split(/\\s+/).map((comp) => {\n\t    return replaceCaret(comp, options)\n\t  }).join(' ');\n\n\tconst replaceCaret = (comp, options) => {\n\t  debug_1('caret', comp, options);\n\t  const r = options.loose ? re$3[t$3.CARETLOOSE] : re$3[t$3.CARET];\n\t  const z = options.includePrerelease ? '-0' : '';\n\t  return comp.replace(r, (_, M, m, p, pr) => {\n\t    debug_1('caret', comp, _, M, m, p, pr);\n\t    let ret;\n\n\t    if (isX(M)) {\n\t      ret = '';\n\t    } else if (isX(m)) {\n\t      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;\n\t    } else if (isX(p)) {\n\t      if (M === '0') {\n\t        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;\n\t      } else {\n\t        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;\n\t      }\n\t    } else if (pr) {\n\t      debug_1('replaceCaret pr', pr);\n\t      if (M === '0') {\n\t        if (m === '0') {\n\t          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`;\n\t        } else {\n\t          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`;\n\t        }\n\t      } else {\n\t        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`;\n\t      }\n\t    } else {\n\t      debug_1('no pr');\n\t      if (M === '0') {\n\t        if (m === '0') {\n\t          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`;\n\t        } else {\n\t          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`;\n\t        }\n\t      } else {\n\t        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`;\n\t      }\n\t    }\n\n\t    debug_1('caret return', ret);\n\t    return ret\n\t  })\n\t};\n\n\tconst replaceXRanges = (comp, options) => {\n\t  debug_1('replaceXRanges', comp, options);\n\t  return comp.split(/\\s+/).map((comp) => {\n\t    return replaceXRange(comp, options)\n\t  }).join(' ')\n\t};\n\n\tconst replaceXRange = (comp, options) => {\n\t  comp = comp.trim();\n\t  const r = options.loose ? re$3[t$3.XRANGELOOSE] : re$3[t$3.XRANGE];\n\t  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n\t    debug_1('xRange', comp, ret, gtlt, M, m, p, pr);\n\t    const xM = isX(M);\n\t    const xm = xM || isX(m);\n\t    const xp = xm || isX(p);\n\t    const anyX = xp;\n\n\t    if (gtlt === '=' && anyX) {\n\t      gtlt = '';\n\t    }\n\n\t    // if we're including prereleases in the match, then we need\n\t    // to fix this to -0, the lowest possible prerelease value\n\t    pr = options.includePrerelease ? '-0' : '';\n\n\t    if (xM) {\n\t      if (gtlt === '>' || gtlt === '<') {\n\t        // nothing is allowed\n\t        ret = '<0.0.0-0';\n\t      } else {\n\t        // nothing is forbidden\n\t        ret = '*';\n\t      }\n\t    } else if (gtlt && anyX) {\n\t      // we know patch is an x, because we have any x at all.\n\t      // replace X with 0\n\t      if (xm) {\n\t        m = 0;\n\t      }\n\t      p = 0;\n\n\t      if (gtlt === '>') {\n\t        // >1 => >=2.0.0\n\t        // >1.2 => >=1.3.0\n\t        gtlt = '>=';\n\t        if (xm) {\n\t          M = +M + 1;\n\t          m = 0;\n\t          p = 0;\n\t        } else {\n\t          m = +m + 1;\n\t          p = 0;\n\t        }\n\t      } else if (gtlt === '<=') {\n\t        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n\t        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n\t        gtlt = '<';\n\t        if (xm) {\n\t          M = +M + 1;\n\t        } else {\n\t          m = +m + 1;\n\t        }\n\t      }\n\n\t      if (gtlt === '<')\n\t        pr = '-0';\n\n\t      ret = `${gtlt + M}.${m}.${p}${pr}`;\n\t    } else if (xm) {\n\t      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;\n\t    } else if (xp) {\n\t      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`;\n\t    }\n\n\t    debug_1('xRange return', ret);\n\n\t    return ret\n\t  })\n\t};\n\n\t// Because * is AND-ed with everything else in the comparator,\n\t// and '' means \"any version\", just remove the *s entirely.\n\tconst replaceStars = (comp, options) => {\n\t  debug_1('replaceStars', comp, options);\n\t  // Looseness is ignored here.  star is always as loose as it gets!\n\t  return comp.trim().replace(re$3[t$3.STAR], '')\n\t};\n\n\tconst replaceGTE0 = (comp, options) => {\n\t  debug_1('replaceGTE0', comp, options);\n\t  return comp.trim()\n\t    .replace(re$3[options.includePrerelease ? t$3.GTE0PRE : t$3.GTE0], '')\n\t};\n\n\t// This function is passed to string.replace(re[t.HYPHENRANGE])\n\t// M, m, patch, prerelease, build\n\t// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n\t// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n\t// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n\tconst hyphenReplace = incPr => ($0,\n\t  from, fM, fm, fp, fpr, fb,\n\t  to, tM, tm, tp, tpr, tb) => {\n\t  if (isX(fM)) {\n\t    from = '';\n\t  } else if (isX(fm)) {\n\t    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;\n\t  } else if (isX(fp)) {\n\t    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;\n\t  } else if (fpr) {\n\t    from = `>=${from}`;\n\t  } else {\n\t    from = `>=${from}${incPr ? '-0' : ''}`;\n\t  }\n\n\t  if (isX(tM)) {\n\t    to = '';\n\t  } else if (isX(tm)) {\n\t    to = `<${+tM + 1}.0.0-0`;\n\t  } else if (isX(tp)) {\n\t    to = `<${tM}.${+tm + 1}.0-0`;\n\t  } else if (tpr) {\n\t    to = `<=${tM}.${tm}.${tp}-${tpr}`;\n\t  } else if (incPr) {\n\t    to = `<${tM}.${tm}.${+tp + 1}-0`;\n\t  } else {\n\t    to = `<=${to}`;\n\t  }\n\n\t  return (`${from} ${to}`).trim()\n\t};\n\n\tconst testSet = (set, version, options) => {\n\t  for (let i = 0; i < set.length; i++) {\n\t    if (!set[i].test(version)) {\n\t      return false\n\t    }\n\t  }\n\n\t  if (version.prerelease.length && !options.includePrerelease) {\n\t    // Find the set of versions that are allowed to have prereleases\n\t    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n\t    // That should allow `1.2.3-pr.2` to pass.\n\t    // However, `1.2.4-alpha.notready` should NOT be allowed,\n\t    // even though it's within the range set by the comparators.\n\t    for (let i = 0; i < set.length; i++) {\n\t      debug_1(set[i].semver);\n\t      if (set[i].semver === comparator.ANY) {\n\t        continue\n\t      }\n\n\t      if (set[i].semver.prerelease.length > 0) {\n\t        const allowed = set[i].semver;\n\t        if (allowed.major === version.major &&\n\t            allowed.minor === version.minor &&\n\t            allowed.patch === version.patch) {\n\t          return true\n\t        }\n\t      }\n\t    }\n\n\t    // Version has a -pre, but it's not one of the ones we like.\n\t    return false\n\t  }\n\n\t  return true\n\t};\n\n\tconst ANY = Symbol('SemVer ANY');\n\t// hoisted class for cyclic dependency\n\tclass Comparator {\n\t  static get ANY () {\n\t    return ANY\n\t  }\n\t  constructor (comp, options) {\n\t    options = parseOptions_1(options);\n\n\t    if (comp instanceof Comparator) {\n\t      if (comp.loose === !!options.loose) {\n\t        return comp\n\t      } else {\n\t        comp = comp.value;\n\t      }\n\t    }\n\n\t    debug_1('comparator', comp, options);\n\t    this.options = options;\n\t    this.loose = !!options.loose;\n\t    this.parse(comp);\n\n\t    if (this.semver === ANY) {\n\t      this.value = '';\n\t    } else {\n\t      this.value = this.operator + this.semver.version;\n\t    }\n\n\t    debug_1('comp', this);\n\t  }\n\n\t  parse (comp) {\n\t    const r = this.options.loose ? re$4[t$4.COMPARATORLOOSE] : re$4[t$4.COMPARATOR];\n\t    const m = comp.match(r);\n\n\t    if (!m) {\n\t      throw new TypeError(`Invalid comparator: ${comp}`)\n\t    }\n\n\t    this.operator = m[1] !== undefined ? m[1] : '';\n\t    if (this.operator === '=') {\n\t      this.operator = '';\n\t    }\n\n\t    // if it literally is just '>' or '' then allow anything.\n\t    if (!m[2]) {\n\t      this.semver = ANY;\n\t    } else {\n\t      this.semver = new semver(m[2], this.options.loose);\n\t    }\n\t  }\n\n\t  toString () {\n\t    return this.value\n\t  }\n\n\t  test (version) {\n\t    debug_1('Comparator.test', version, this.options.loose);\n\n\t    if (this.semver === ANY || version === ANY) {\n\t      return true\n\t    }\n\n\t    if (typeof version === 'string') {\n\t      try {\n\t        version = new semver(version, this.options);\n\t      } catch (er) {\n\t        return false\n\t      }\n\t    }\n\n\t    return cmp_1(version, this.operator, this.semver, this.options)\n\t  }\n\n\t  intersects (comp, options) {\n\t    if (!(comp instanceof Comparator)) {\n\t      throw new TypeError('a Comparator is required')\n\t    }\n\n\t    if (!options || typeof options !== 'object') {\n\t      options = {\n\t        loose: !!options,\n\t        includePrerelease: false\n\t      };\n\t    }\n\n\t    if (this.operator === '') {\n\t      if (this.value === '') {\n\t        return true\n\t      }\n\t      return new range(comp.value, options).test(this.value)\n\t    } else if (comp.operator === '') {\n\t      if (comp.value === '') {\n\t        return true\n\t      }\n\t      return new range(this.value, options).test(comp.semver)\n\t    }\n\n\t    const sameDirectionIncreasing =\n\t      (this.operator === '>=' || this.operator === '>') &&\n\t      (comp.operator === '>=' || comp.operator === '>');\n\t    const sameDirectionDecreasing =\n\t      (this.operator === '<=' || this.operator === '<') &&\n\t      (comp.operator === '<=' || comp.operator === '<');\n\t    const sameSemVer = this.semver.version === comp.semver.version;\n\t    const differentDirectionsInclusive =\n\t      (this.operator === '>=' || this.operator === '<=') &&\n\t      (comp.operator === '>=' || comp.operator === '<=');\n\t    const oppositeDirectionsLessThan =\n\t      cmp_1(this.semver, '<', comp.semver, options) &&\n\t      (this.operator === '>=' || this.operator === '>') &&\n\t        (comp.operator === '<=' || comp.operator === '<');\n\t    const oppositeDirectionsGreaterThan =\n\t      cmp_1(this.semver, '>', comp.semver, options) &&\n\t      (this.operator === '<=' || this.operator === '<') &&\n\t        (comp.operator === '>=' || comp.operator === '>');\n\n\t    return (\n\t      sameDirectionIncreasing ||\n\t      sameDirectionDecreasing ||\n\t      (sameSemVer && differentDirectionsInclusive) ||\n\t      oppositeDirectionsLessThan ||\n\t      oppositeDirectionsGreaterThan\n\t    )\n\t  }\n\t}\n\n\tvar comparator = Comparator;\n\n\n\tconst {re: re$4, t: t$4} = re_1;\n\n\tconst satisfies = (version, range$1, options) => {\n\t  try {\n\t    range$1 = new range(range$1, options);\n\t  } catch (er) {\n\t    return false\n\t  }\n\t  return range$1.test(version)\n\t};\n\tvar satisfies_1 = satisfies;\n\n\t// Mostly just for testing and legacy API reasons\n\tconst toComparators = (range$1, options) =>\n\t  new range(range$1, options).set\n\t    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));\n\n\tvar toComparators_1 = toComparators;\n\n\tconst maxSatisfying = (versions, range$1, options) => {\n\t  let max = null;\n\t  let maxSV = null;\n\t  let rangeObj = null;\n\t  try {\n\t    rangeObj = new range(range$1, options);\n\t  } catch (er) {\n\t    return null\n\t  }\n\t  versions.forEach((v) => {\n\t    if (rangeObj.test(v)) {\n\t      // satisfies(v, range, options)\n\t      if (!max || maxSV.compare(v) === -1) {\n\t        // compare(max, v, true)\n\t        max = v;\n\t        maxSV = new semver(max, options);\n\t      }\n\t    }\n\t  });\n\t  return max\n\t};\n\tvar maxSatisfying_1 = maxSatisfying;\n\n\tconst minSatisfying = (versions, range$1, options) => {\n\t  let min = null;\n\t  let minSV = null;\n\t  let rangeObj = null;\n\t  try {\n\t    rangeObj = new range(range$1, options);\n\t  } catch (er) {\n\t    return null\n\t  }\n\t  versions.forEach((v) => {\n\t    if (rangeObj.test(v)) {\n\t      // satisfies(v, range, options)\n\t      if (!min || minSV.compare(v) === 1) {\n\t        // compare(min, v, true)\n\t        min = v;\n\t        minSV = new semver(min, options);\n\t      }\n\t    }\n\t  });\n\t  return min\n\t};\n\tvar minSatisfying_1 = minSatisfying;\n\n\tconst minVersion = (range$1, loose) => {\n\t  range$1 = new range(range$1, loose);\n\n\t  let minver = new semver('0.0.0');\n\t  if (range$1.test(minver)) {\n\t    return minver\n\t  }\n\n\t  minver = new semver('0.0.0-0');\n\t  if (range$1.test(minver)) {\n\t    return minver\n\t  }\n\n\t  minver = null;\n\t  for (let i = 0; i < range$1.set.length; ++i) {\n\t    const comparators = range$1.set[i];\n\n\t    let setMin = null;\n\t    comparators.forEach((comparator) => {\n\t      // Clone to avoid manipulating the comparator's semver object.\n\t      const compver = new semver(comparator.semver.version);\n\t      switch (comparator.operator) {\n\t        case '>':\n\t          if (compver.prerelease.length === 0) {\n\t            compver.patch++;\n\t          } else {\n\t            compver.prerelease.push(0);\n\t          }\n\t          compver.raw = compver.format();\n\t          /* fallthrough */\n\t        case '':\n\t        case '>=':\n\t          if (!setMin || gt_1(compver, setMin)) {\n\t            setMin = compver;\n\t          }\n\t          break\n\t        case '<':\n\t        case '<=':\n\t          /* Ignore maximum versions */\n\t          break\n\t        /* istanbul ignore next */\n\t        default:\n\t          throw new Error(`Unexpected operation: ${comparator.operator}`)\n\t      }\n\t    });\n\t    if (setMin && (!minver || gt_1(minver, setMin)))\n\t      minver = setMin;\n\t  }\n\n\t  if (minver && range$1.test(minver)) {\n\t    return minver\n\t  }\n\n\t  return null\n\t};\n\tvar minVersion_1 = minVersion;\n\n\tconst validRange = (range$1, options) => {\n\t  try {\n\t    // Return '*' instead of '' so that truthiness works.\n\t    // This will throw if it's invalid anyway\n\t    return new range(range$1, options).range || '*'\n\t  } catch (er) {\n\t    return null\n\t  }\n\t};\n\tvar valid$1 = validRange;\n\n\tconst {ANY: ANY$1} = comparator;\n\n\n\n\n\n\n\n\tconst outside = (version, range$1, hilo, options) => {\n\t  version = new semver(version, options);\n\t  range$1 = new range(range$1, options);\n\n\t  let gtfn, ltefn, ltfn, comp, ecomp;\n\t  switch (hilo) {\n\t    case '>':\n\t      gtfn = gt_1;\n\t      ltefn = lte_1;\n\t      ltfn = lt_1;\n\t      comp = '>';\n\t      ecomp = '>=';\n\t      break\n\t    case '<':\n\t      gtfn = lt_1;\n\t      ltefn = gte_1;\n\t      ltfn = gt_1;\n\t      comp = '<';\n\t      ecomp = '<=';\n\t      break\n\t    default:\n\t      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n\t  }\n\n\t  // If it satisfies the range it is not outside\n\t  if (satisfies_1(version, range$1, options)) {\n\t    return false\n\t  }\n\n\t  // From now on, variable terms are as if we're in \"gtr\" mode.\n\t  // but note that everything is flipped for the \"ltr\" function.\n\n\t  for (let i = 0; i < range$1.set.length; ++i) {\n\t    const comparators = range$1.set[i];\n\n\t    let high = null;\n\t    let low = null;\n\n\t    comparators.forEach((comparator$1) => {\n\t      if (comparator$1.semver === ANY$1) {\n\t        comparator$1 = new comparator('>=0.0.0');\n\t      }\n\t      high = high || comparator$1;\n\t      low = low || comparator$1;\n\t      if (gtfn(comparator$1.semver, high.semver, options)) {\n\t        high = comparator$1;\n\t      } else if (ltfn(comparator$1.semver, low.semver, options)) {\n\t        low = comparator$1;\n\t      }\n\t    });\n\n\t    // If the edge version comparator has a operator then our version\n\t    // isn't outside it\n\t    if (high.operator === comp || high.operator === ecomp) {\n\t      return false\n\t    }\n\n\t    // If the lowest version comparator has an operator and our version\n\t    // is less than it then it isn't higher than the range\n\t    if ((!low.operator || low.operator === comp) &&\n\t        ltefn(version, low.semver)) {\n\t      return false\n\t    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t};\n\n\tvar outside_1 = outside;\n\n\t// Determine if version is greater than all the versions possible in the range.\n\n\tconst gtr = (version, range, options) => outside_1(version, range, '>', options);\n\tvar gtr_1 = gtr;\n\n\t// Determine if version is less than all the versions possible in the range\n\tconst ltr = (version, range, options) => outside_1(version, range, '<', options);\n\tvar ltr_1 = ltr;\n\n\tconst intersects = (r1, r2, options) => {\n\t  r1 = new range(r1, options);\n\t  r2 = new range(r2, options);\n\t  return r1.intersects(r2)\n\t};\n\tvar intersects_1 = intersects;\n\n\t// given a set of versions and a range, create a \"simplified\" range\n\t// that includes the same versions that the original range does\n\t// If the original range is shorter than the simplified one, return that.\n\n\n\tvar simplify = (versions, range, options) => {\n\t  const set = [];\n\t  let min = null;\n\t  let prev = null;\n\t  const v = versions.sort((a, b) => compare_1(a, b, options));\n\t  for (const version of v) {\n\t    const included = satisfies_1(version, range, options);\n\t    if (included) {\n\t      prev = version;\n\t      if (!min)\n\t        min = version;\n\t    } else {\n\t      if (prev) {\n\t        set.push([min, prev]);\n\t      }\n\t      prev = null;\n\t      min = null;\n\t    }\n\t  }\n\t  if (min)\n\t    set.push([min, null]);\n\n\t  const ranges = [];\n\t  for (const [min, max] of set) {\n\t    if (min === max)\n\t      ranges.push(min);\n\t    else if (!max && min === v[0])\n\t      ranges.push('*');\n\t    else if (!max)\n\t      ranges.push(`>=${min}`);\n\t    else if (min === v[0])\n\t      ranges.push(`<=${max}`);\n\t    else\n\t      ranges.push(`${min} - ${max}`);\n\t  }\n\t  const simplified = ranges.join(' || ');\n\t  const original = typeof range.raw === 'string' ? range.raw : String(range);\n\t  return simplified.length < original.length ? simplified : range\n\t};\n\n\tconst { ANY: ANY$2 } = comparator;\n\n\n\n\t// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n\t// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`\n\t//\n\t// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n\t// - If c is only the ANY comparator\n\t//   - If C is only the ANY comparator, return true\n\t//   - Else return false\n\t// - Let EQ be the set of = comparators in c\n\t// - If EQ is more than one, return true (null set)\n\t// - Let GT be the highest > or >= comparator in c\n\t// - Let LT be the lowest < or <= comparator in c\n\t// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n\t// - If EQ\n\t//   - If GT, and EQ does not satisfy GT, return true (null set)\n\t//   - If LT, and EQ does not satisfy LT, return true (null set)\n\t//   - If EQ satisfies every C, return true\n\t//   - Else return false\n\t// - If GT\n\t//   - If GT.semver is lower than any > or >= comp in C, return false\n\t//   - If GT is >=, and GT.semver does not satisfy every C, return false\n\t// - If LT\n\t//   - If LT.semver is greater than any < or <= comp in C, return false\n\t//   - If LT is <=, and LT.semver does not satisfy every C, return false\n\t// - If any C is a = range, and GT or LT are set, return false\n\t// - Else return true\n\n\tconst subset = (sub, dom, options) => {\n\t  if (sub === dom)\n\t    return true\n\n\t  sub = new range(sub, options);\n\t  dom = new range(dom, options);\n\t  let sawNonNull = false;\n\n\t  OUTER: for (const simpleSub of sub.set) {\n\t    for (const simpleDom of dom.set) {\n\t      const isSub = simpleSubset(simpleSub, simpleDom, options);\n\t      sawNonNull = sawNonNull || isSub !== null;\n\t      if (isSub)\n\t        continue OUTER\n\t    }\n\t    // the null set is a subset of everything, but null simple ranges in\n\t    // a complex range should be ignored.  so if we saw a non-null range,\n\t    // then we know this isn't a subset, but if EVERY simple range was null,\n\t    // then it is a subset.\n\t    if (sawNonNull)\n\t      return false\n\t  }\n\t  return true\n\t};\n\n\tconst simpleSubset = (sub, dom, options) => {\n\t  if (sub === dom)\n\t    return true\n\n\t  if (sub.length === 1 && sub[0].semver === ANY$2)\n\t    return dom.length === 1 && dom[0].semver === ANY$2\n\n\t  const eqSet = new Set();\n\t  let gt, lt;\n\t  for (const c of sub) {\n\t    if (c.operator === '>' || c.operator === '>=')\n\t      gt = higherGT(gt, c, options);\n\t    else if (c.operator === '<' || c.operator === '<=')\n\t      lt = lowerLT(lt, c, options);\n\t    else\n\t      eqSet.add(c.semver);\n\t  }\n\n\t  if (eqSet.size > 1)\n\t    return null\n\n\t  let gtltComp;\n\t  if (gt && lt) {\n\t    gtltComp = compare_1(gt.semver, lt.semver, options);\n\t    if (gtltComp > 0)\n\t      return null\n\t    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n\t      return null\n\t  }\n\n\t  // will iterate one or zero times\n\t  for (const eq of eqSet) {\n\t    if (gt && !satisfies_1(eq, String(gt), options))\n\t      return null\n\n\t    if (lt && !satisfies_1(eq, String(lt), options))\n\t      return null\n\n\t    for (const c of dom) {\n\t      if (!satisfies_1(eq, String(c), options))\n\t        return false\n\t    }\n\n\t    return true\n\t  }\n\n\t  let higher, lower;\n\t  let hasDomLT, hasDomGT;\n\t  for (const c of dom) {\n\t    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';\n\t    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';\n\t    if (gt) {\n\t      if (c.operator === '>' || c.operator === '>=') {\n\t        higher = higherGT(gt, c, options);\n\t        if (higher === c && higher !== gt)\n\t          return false\n\t      } else if (gt.operator === '>=' && !satisfies_1(gt.semver, String(c), options))\n\t        return false\n\t    }\n\t    if (lt) {\n\t      if (c.operator === '<' || c.operator === '<=') {\n\t        lower = lowerLT(lt, c, options);\n\t        if (lower === c && lower !== lt)\n\t          return false\n\t      } else if (lt.operator === '<=' && !satisfies_1(lt.semver, String(c), options))\n\t        return false\n\t    }\n\t    if (!c.operator && (lt || gt) && gtltComp !== 0)\n\t      return false\n\t  }\n\n\t  // if there was a < or >, and nothing in the dom, then must be false\n\t  // UNLESS it was limited by another range in the other direction.\n\t  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n\t  if (gt && hasDomLT && !lt && gtltComp !== 0)\n\t    return false\n\n\t  if (lt && hasDomGT && !gt && gtltComp !== 0)\n\t    return false\n\n\t  return true\n\t};\n\n\t// >=1.2.3 is lower than >1.2.3\n\tconst higherGT = (a, b, options) => {\n\t  if (!a)\n\t    return b\n\t  const comp = compare_1(a.semver, b.semver, options);\n\t  return comp > 0 ? a\n\t    : comp < 0 ? b\n\t    : b.operator === '>' && a.operator === '>=' ? b\n\t    : a\n\t};\n\n\t// <=1.2.3 is higher than <1.2.3\n\tconst lowerLT = (a, b, options) => {\n\t  if (!a)\n\t    return b\n\t  const comp = compare_1(a.semver, b.semver, options);\n\t  return comp < 0 ? a\n\t    : comp > 0 ? b\n\t    : b.operator === '<' && a.operator === '<=' ? b\n\t    : a\n\t};\n\n\tvar subset_1 = subset;\n\n\t// just pre-load all the stuff that index.js lazily exports\n\n\tvar semver$1 = {\n\t  re: re_1.re,\n\t  src: re_1.src,\n\t  tokens: re_1.t,\n\t  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n\t  SemVer: semver,\n\t  compareIdentifiers: identifiers.compareIdentifiers,\n\t  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n\t  parse: parse_1,\n\t  valid: valid_1,\n\t  clean: clean_1,\n\t  inc: inc_1,\n\t  diff: diff_1,\n\t  major: major_1,\n\t  minor: minor_1,\n\t  patch: patch_1,\n\t  prerelease: prerelease_1,\n\t  compare: compare_1,\n\t  rcompare: rcompare_1,\n\t  compareLoose: compareLoose_1,\n\t  compareBuild: compareBuild_1,\n\t  sort: sort_1,\n\t  rsort: rsort_1,\n\t  gt: gt_1,\n\t  lt: lt_1,\n\t  eq: eq_1,\n\t  neq: neq_1,\n\t  gte: gte_1,\n\t  lte: lte_1,\n\t  cmp: cmp_1,\n\t  coerce: coerce_1,\n\t  Comparator: comparator,\n\t  Range: range,\n\t  satisfies: satisfies_1,\n\t  toComparators: toComparators_1,\n\t  maxSatisfying: maxSatisfying_1,\n\t  minSatisfying: minSatisfying_1,\n\t  minVersion: minVersion_1,\n\t  validRange: valid$1,\n\t  outside: outside_1,\n\t  gtr: gtr_1,\n\t  ltr: ltr_1,\n\t  intersects: intersects_1,\n\t  simplifyRange: simplify,\n\t  subset: subset_1,\n\t};\n\n\tclass Semversion {\r\n\t    constructor(ver) {\r\n\t        this._version = semver$1.parse(ver);\r\n\t    }\r\n\t    get isValid() {\r\n\t        return !!this._version;\r\n\t    }\r\n\t    get raw() {\r\n\t        var _a;\r\n\t        return (_a = this._version) === null || _a === void 0 ? void 0 : _a.raw;\r\n\t    }\r\n\t    get version() {\r\n\t        var _a;\r\n\t        return (_a = this._version) === null || _a === void 0 ? void 0 : _a.version;\r\n\t    }\r\n\t    get full() {\r\n\t        var _a;\r\n\t        let str = (_a = this.version) !== null && _a !== void 0 ? _a : '';\r\n\t        str += this.hasBuild ? `+${this.build}` : '';\r\n\t        return str;\r\n\t    }\r\n\t    get major() {\r\n\t        var _a;\r\n\t        return (_a = this._version) === null || _a === void 0 ? void 0 : _a.major;\r\n\t    }\r\n\t    get minor() {\r\n\t        var _a;\r\n\t        return (_a = this._version) === null || _a === void 0 ? void 0 : _a.minor;\r\n\t    }\r\n\t    get patch() {\r\n\t        var _a;\r\n\t        return (_a = this._version) === null || _a === void 0 ? void 0 : _a.patch;\r\n\t    }\r\n\t    get hasBuild() {\r\n\t        var _a, _b;\r\n\t        return !!((_b = (_a = this._version) === null || _a === void 0 ? void 0 : _a.build) === null || _b === void 0 ? void 0 : _b.length);\r\n\t    }\r\n\t    get build() {\r\n\t        var _a;\r\n\t        return this.hasBuild ? (_a = this._version) === null || _a === void 0 ? void 0 : _a.build.join('.') : undefined;\r\n\t    }\r\n\t    get buildValues() {\r\n\t        var _a;\r\n\t        return this.hasBuild ? (_a = this._version) === null || _a === void 0 ? void 0 : _a.build : undefined;\r\n\t    }\r\n\t    get isPrerelease() {\r\n\t        var _a, _b;\r\n\t        return !!((_b = (_a = this._version) === null || _a === void 0 ? void 0 : _a.prerelease) === null || _b === void 0 ? void 0 : _b.length);\r\n\t    }\r\n\t    get prereleaseId() {\r\n\t        var _a;\r\n\t        return this.isPrerelease ? (_a = this._version) === null || _a === void 0 ? void 0 : _a.prerelease[0].toString() : undefined;\r\n\t    }\r\n\t    get prereleaseValues() {\r\n\t        var _a;\r\n\t        return this.isPrerelease ? (_a = this._version) === null || _a === void 0 ? void 0 : _a.prerelease : undefined;\r\n\t    }\r\n\t    get prerelease() {\r\n\t        return this.isPrerelease ? this._version.prerelease.join('.') : undefined;\r\n\t    }\r\n\t    toString() {\r\n\t        var _a;\r\n\t        return (_a = this.full) !== null && _a !== void 0 ? _a : '[Invalid Semver]';\r\n\t    }\r\n\t    toJSON() {\r\n\t        if (this.isValid) {\r\n\t            return {\r\n\t                build: this.build,\r\n\t                buildValues: this.buildValues,\r\n\t                version: this.version,\r\n\t                full: this.full,\r\n\t                hasBuild: this.hasBuild,\r\n\t                isPrerelease: this.isPrerelease,\r\n\t                isValid: this.isValid,\r\n\t                major: this.major,\r\n\t                minor: this.minor,\r\n\t                patch: this.patch,\r\n\t                prerelease: this.prerelease,\r\n\t                prereleaseId: this.prereleaseId,\r\n\t                prereleaseValues: this.prereleaseValues,\r\n\t                raw: this.raw\r\n\t            };\r\n\t        }\r\n\t        return null;\r\n\t    }\r\n\t}\n\n\texports.Semversion = Semversion;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=tslib-semver.umd.js.map\n","module.exports = require(\"fs\");;","module.exports = require(\"os\");;","module.exports = require(\"path\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n__webpack_require__.ab = __dirname + \"/\";","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(283);\n"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACnBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChtFA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;ACDA;AACA;AACA;AACA;;A","sourceRoot":""}